package transportc

import (
	"errors"
	"math/rand"
	"sync"
	"time"
)

type SignalMethod interface {
	// MakeOffer sends the SDP offer generated by offerer to the answerer.
	//
	// Called by Offerer.
	MakeOffer(offer []byte) (offerID uint64, err error)

	// GetOffer SHOULD return an error if Offer is not yet received/available.
	// However, blocking until an offer is received is also acceptable.
	//
	// Called by Answerer (after Offerer calling MakeOffer).
	GetOffer() (offerID uint64, offerBody []byte, err error)

	// Answer sends the SDP answer generated by answerer to the offerer.
	//
	// Called by Answerer (after Answerer calling GetOffer)
	Answer(offerID uint64, answer []byte) error

	// GetAnswer blocks until the next SDP answer is available.
	//
	// Called by Offerer (after Answerer calling Answer)
	GetAnswer(offerID uint64) ([]byte, error)
}

var (
	// SignalMethodManual won't automatically establish a connection.
	// The connection will be established once both party have called SetRemoteDescription.
	SignalMethodManual SignalMethod = nil
)

// IOSignal implements a minimalistic signaling method.
// Offerer's writer should write to the answerer's reader and vice versa.
type DebugSignal struct {
	offers      chan offer
	answers     map[uint64][]byte
	answerMutex sync.Mutex
}

type offer struct {
	id   uint64
	body []byte
}

// NewDebugSignal creates a new DebugSignal.
func NewDebugSignal(bufferSize int) *DebugSignal {
	return &DebugSignal{
		offers:  make(chan offer, bufferSize),
		answers: make(map[uint64][]byte),
	}
}

// MakeOffer implements SignalMethod.MakeOffer.
// It writes the SDP offer to offers channel.
func (ds *DebugSignal) MakeOffer(offerBody []byte) (uint64, error) {
	id := rand.Uint64()

	ds.offers <- offer{
		id:   id,
		body: offerBody,
	}
	return id, nil
}

// GetOffer implements SignalMethod.GetOffer
// It reads the SDP offer from offers channel.
func (ds *DebugSignal) GetOffer() (uint64, []byte, error) {
	if len(ds.offers) == 0 {
		return 0, nil, errors.New("no offer available")
	}
	offer := <-ds.offers
	return offer.id, offer.body, nil
}

// Answer implements SignalMethod.Answer.
// It writes the SDP answer to answers channel.
func (ds *DebugSignal) Answer(offerID uint64, answer []byte) error {
	ds.answerMutex.Lock()
	defer ds.answerMutex.Unlock()

	// make sure the offerID is unique
	if _, ok := ds.answers[offerID]; ok {
		return errors.New("offerID already exists")
	}

	ds.answers[offerID] = answer
	return nil
}

// GetAnswer implements SignalMethod.GetAnswer
// It reads the SDP answer from answers channel.
func (ds *DebugSignal) GetAnswer(offerID uint64) ([]byte, error) {
	ds.answerMutex.Lock()
	defer ds.answerMutex.Unlock()

	answer, ok := ds.answers[offerID]
	for !ok {
		ds.answerMutex.Unlock()
		time.Sleep(time.Millisecond * 50)
		ds.answerMutex.Lock()
		answer, ok = ds.answers[offerID]
	}
	// delete the answer so it can't be used again
	delete(ds.answers, offerID)

	return answer, nil
}
